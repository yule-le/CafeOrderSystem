Day 1 – 專案規劃

任務

明確需求：Customer 功能、Admin 功能、支付、SignalR、報表

設計資料庫 ER 圖（Users, Products, Orders, OrderItems）

確定專案目錄結構（Api、Client、SignalR、Tests）

列出 API Endpoint 清單

前端頁面規劃（Customer 與 Admin）

Day 2 – 建立專案與基本架構

後端

建立 .NET Core Web API 專案

建立 AppDbContext + EF Core Migrations

安裝並設定 JWT 認證

設定 Role-based Authorization（Customer / Admin）

前端

建立 Blazor WebAssembly 或 React 專案

設定前端路由與登入頁面骨架

Day 3 – Product 模組

後端

Product Entity + DTO

Repository + Service + Controller

實作 CRUD：GetAll, GetById, Create, Update, Delete

單元測試 ProductService

前端

商品列表頁骨架

與 API 對接顯示商品

Day 4 – User 模組 & JWT 登入

後端

User 註冊 / 登入 API

密碼 Hash (BCrypt)

JWT Token 生成

前端

註冊 / 登入頁面

儲存 JWT Token

保護路由：登入後才能下單或進入管理頁

Day 5 – Order / OrderItem 模組

後端

Order + OrderItem Entity + DTO

Repository + Service + Controller

客戶下單功能（建立 Order, 計算 TotalAmount）

客戶查詢自己的訂單

前端

購物車功能 + 下單流程

Day 6 – 前端商品與購物車

前端

商品列表顯示

商品加入購物車 / 編輯數量 / 移除

計算購物車總價

測試

使用 Postman 測試 Product / Order API

Day 7 – 客戶端下單與訂單歷史

前端

下單頁面：送出 Order API

訂單歷史頁：顯示客戶過往訂單

後端

確保 Order 狀態初始為 Pending

Day 8 – 管理端菜單管理

後端

Product CRUD API 完整測試

前端

Admin 商品管理頁（新增 / 編輯 / 刪除）

權限檢查：只有 Admin 可以操作

Day 9 – 管理端訂單管理

後端

Order API: 管理員可以查看所有訂單

訂單狀態修改 API (Pending → InProgress → Completed)

前端

訂單管理頁面

下拉選單修改訂單狀態

Day 10 – SignalR 即時通知

後端

建立 OrderHub.cs

當管理員修改訂單狀態時，透過 SignalR 發送訊息給對應客戶

前端

客戶端接收訂單狀態更新並即時顯示

Day 11 – 支付整合

後端

整合 Stripe 或 PayPal Sandbox API

建立 PaymentIntent 或 PaymentOrder API

前端

客戶端支付頁面

支付成功後自動建立訂單並通知管理端

Day 12 – 報表功能

後端

API 提供簡單銷售報表：每日銷售量、熱門商品

前端

Admin 報表頁面

圖表顯示 (可用 Chart.js 或 Blazor Chart)

Day 13 – 測試與錯誤處理

後端

單元測試：ProductService、OrderService、UserService

全域錯誤處理 Middleware

前端

前端整合測試，確保 API 串接正確

表單驗證 (Blazor / React)

Day 14 – 最後美化與部署

後端

Swagger / OpenAPI 文件完成

Production appsettings.json 配置

前端

UI 美化，完善響應式布局

SignalR 與支付功能最終測試

整合

確保整個流程：商品瀏覽 → 下單 → 支付 → 訂單狀態通知 → 管理報表都正常